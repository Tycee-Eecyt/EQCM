<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Getting Started — Google Sheets Backend</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 18px; line-height: 1.45; max-width: 900px; }
    code, pre { background: #f5f5f5; padding: 2px 4px; border-radius: 4px; }
    pre { padding: 12px; overflow: auto; }
    h2 { margin-top: 24px; }
    ol li { margin-bottom: 8px; }
  </style>
</head>
<body>
  <h1>Getting Started — Google Sheets Backend</h1>
  <p>This page helps you deploy the Apps Script that the tray app calls. It also supports per-character <b>Push inventory to sheet</b> tabs like your screenshot layout.</p>

  <h2>1. Create a Spreadsheet</h2>
  <ol>
    <li>Create a new Google Sheet (or reuse an existing one).</li>
    <li>Copy its URL and paste it into the app <b>Settings → Spreadsheet URL</b>.</li>
  </ol>

  <h2>2. Create an Apps Script Project</h2>
  <ol>
    <li>Open <b>Extensions → Apps Script</b> in the Sheet.</li>
    <li>Replace <b>Code.gs</b> with the contents below.</li>
    <li>Set <b>CONFIG.SECRET</b> to your shared secret (optional) — match it in the app settings.</li>
    <li>Deploy: <b>Deploy → New deployment → Web app</b> → Execute as <i>Me</i> → Who has access <i>Anyone with link</i>.</li>
    <li>Copy the <b>/exec</b> URL into the app <b>Settings → Apps Script /exec URL</b>.</li>
  </ol>

  <h2>3. Code.gs</h2>
  <p>You can copy the file at <code>docs/Code.gs</code> from this repo, or paste the snippet below into your Apps Script project.</p>
  <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px">
    <button id="copyAll">Copy All</button>
    <span class="small" id="copyStatus"></span>
  </div>
  <pre id="code"></pre>

  <script>
  const code = `// Code.gs — Google Apps Script backend for EQ Character Manager
const CONFIG = {
  SECRET: '',              // Optional: set a shared secret string; leave blank to disable check
  ZONES_SHEET: 'Zone Tracker',
  FACTION_SHEET: 'CoV Faction',
  // Inventory summary tab name
  INV_SUMMARY_SHEET: 'Raid Kit',
  INV_ITEMS_SHEET: 'Inventory Items' // optional catch-all
};

function doPost(e){
  try{
    const body = JSON.parse(e.postData && e.postData.contents || '{}');
    if (CONFIG.SECRET && String(body.secret||'') !== CONFIG.SECRET) {
      return ContentService.createTextOutput('Unauthorized').setMimeType(ContentService.MimeType.TEXT).setResponseCode(401);
    }
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    if (body.action === 'pushInventorySheet'){
      return respond_(pushInventorySheet_(ss, body));
    }
    if (body.action === 'replaceAll'){
      replaceAll_(ss, body);
      return respond_({ ok: true, mode: 'replaceAll' });
    }
    if (body.action === 'listCharacters'){
      const res = listCharacters_(ss);
      return respond_(res);
    }
    // Replace CoV Faction tab with EXACT CSV contents
    if (body.action === 'replaceFactionsCsv'){
      const csv = String(body.csv || '');
      if (!csv) return respond_({ ok:false, error: 'Missing csv' }, 400);
      const res = replaceFactionsCsv_(ss, csv);
      return respond_({ ok: true, mode: 'replaceFactionsCsv', rows: res.rows, cols: res.cols });
    }
    // Block JSON writes to factions: accept only CSV action above
    if (body.action === 'replaceFactions'){
      return respond_({ ok:false, error: 'Factions JSON disabled; use action=replaceFactionsCsv' }, 403);
    }
    // Optional bulk JSON import for other tabs (faster path). CoV Faction is guarded and skipped here.
    if (body.action === 'jsonImport'){
      const res = jsonImport_(ss, body);
      return respond_(Object.assign({ ok:true, mode:'jsonImport' }, res));
    }

    const upserts = body.upserts || {};
    if (upserts.zones)    upsertZones_(ss, upserts.zones);
    // Factions JSON is ignored by design; only CSV is accepted to modify the CoV Faction tab
    if (upserts.inventory) upsertInventorySummary_(ss, upserts.inventory, body.meta || {});
    if (upserts.inventoryDetails) upsertInventoryDetails_(ss, upserts.inventoryDetails);
    return respond_({ ok: true });
  }catch(err){
    return respond_({ ok:false, error: String(err && err.stack || err) }, 500);
  }
}

function respond_(obj, code){
  const out = ContentService.createTextOutput(JSON.stringify(obj));
  out.setMimeType(ContentService.MimeType.JSON);
  if (code) out.setResponseCode(code);
  return out;
}

function getOrMakeSheet_(ss, name){
  let sh = ss.getSheetByName(name);
  if (!sh) sh = ss.insertSheet(name);
  return sh;
}

function ensureHeader_(sh, header){
  const existing = sh.getRange(1,1,1,sh.getMaxColumns()).getValues()[0].filter(String);
  if (existing.join('\t') !== header.join('\t')){
    sh.clearContents();
    sh.getRange(1,1,1,header.length).setValues([header]);
  }
}

function upsertRowsByKey_(sh, header, keyCol, rows){
  ensureHeader_(sh, header);
  const idx = header.indexOf(keyCol) + 1;
  const data = sh.getDataRange().getValues();
  const map = new Map();
  for (let r=1; r<data.length; r++){
    const k = String(data[r][idx-1]||'');
    if (k) map.set(k, r+1);
  }
  rows.forEach(row => {
    const key = String(row[header.indexOf(keyCol)]||'');
    if (!key) return;
    let r = map.get(key);
    if (r){
      sh.getRange(r,1,1,header.length).setValues([row]);
    } else {
      sh.appendRow(row);
      map.set(key, sh.getLastRow());
    }
  });
}

function writeAllRows_(sh, header, rows){
  sh.clearContents();
  sh.getRange(1,1,1,header.length).setValues([header]);
  if (rows && rows.length){
    sh.getRange(2,1,rows.length,header.length).setValues(rows);
  }
}

function upsertZones_(ss, rows){
  const header = ['Character','Last Zone','Zone Time (UTC)','Zone Time (Local)','Device TZ','Source Log File'];
  const sh = getOrMakeSheet_(ss, CONFIG.ZONES_SHEET);
  const data = rows.map(o => [o.character,o.zone,o.utc,o.local,o.tz,o.source]);
  // Key by Source Log File so same character on different servers are separate rows
  upsertRowsByKey_(sh, header, 'Source Log File', data);
}

function replaceZones_(ss, rows){
  const header = ['Character','Last Zone','Zone Time (UTC)','Zone Time (Local)','Device TZ','Source Log File'];
  const sh = getOrMakeSheet_(ss, CONFIG.ZONES_SHEET);
  const data = (rows||[]).map(o => [o.character,o.zone,o.utc,o.local,o.tz,o.source]);
  writeAllRows_(sh, header, data);
}

function upsertFactions_(ss, rows){
  const header = ['Character','Standing','Score','Mob','Consider Time (UTC)','Consider Time (Local)','Notes'];
  const sh = getOrMakeSheet_(ss, CONFIG.FACTION_SHEET);
  const data = rows.map(o => [o.character,o.standing,o.score,o.mob,o.utc,o.local,(o.standingDisplay||'')]);
  upsertRowsByKey_(sh, header, 'Character', data);
}

function replaceFactions_(ss, rows){
  const header = ['Character','Standing','Score','Mob','Consider Time (UTC)','Consider Time (Local)','Notes'];
  const sh = getOrMakeSheet_(ss, CONFIG.FACTION_SHEET);
  const data = (rows||[]).map(o => [o.character,o.standing,o.score,o.mob,o.utc,o.local,(o.standingDisplay||'')]);
  writeAllRows_(sh, header, data);
}

// Replace CoV Faction with the EXACT contents of a CSV string
function replaceFactionsCsv_(ss, csvText){
  const sh = getOrMakeSheet_(ss, CONFIG.FACTION_SHEET);
  const rows = Utilities.parseCsv(csvText || '');
  // Clear and write exactly what the CSV contains (including header row as-is)
  sh.clearContents();
  if (rows && rows.length){
    sh.getRange(1,1,rows.length,rows[0].length).setValues(rows);
    return { rows: rows.length, cols: rows[0].length };
  }
  return { rows: 0, cols: 0 };
}

function upsertInventorySummary_(ss, rows, meta){
  const fixedHeaders = (meta && meta.invFixedHeaders && meta.invFixedHeaders.length) ? meta.invFixedHeaders : [
    'Vial of Velium Vapors','Leatherfoot Raider Skullcap','Shiny Brass Idol','Ring of Shadows Count',
    'Reaper of the Dead','Pearl Count','Peridot Count','10 Dose Potion of Stinging Wort Count','Pegasus Feather Cloak',
    'MB Class Five','MB Class Four','MB Class Three','MB Class Two','MB Class One','Larrikan\'s Mask'
  ];
  const fixedProps = (meta && meta.invFixedProps && meta.invFixedProps.length) ? meta.invFixedProps : [
    'vialVeliumVapors','leatherfootSkullcap','shinyBrassIdol','ringOfShadowsCount',
    'reaperOfTheDead','pearlCount','peridotCount','tenDosePotionOfStingingWortCount','pegasusFeatherCloak',
    'mbClassFive','mbClassFour','mbClassThree','mbClassTwo','mbClassOne','larrikansMask'
  ];
  const base = ['Character','Inventory File','Source Log File','Created (UTC)','Modified (UTC)'].concat(fixedHeaders);
  // Union any extra kit columns provided as o.kitExtras { HeaderLabel: value }
  const extrasSet = new Set();
  (rows||[]).forEach(o => { const ex = o.kitExtras||{}; Object.keys(ex).forEach(k => extrasSet.add(String(k))); });
  const extras = Array.from(extrasSet);
  const header = base.concat(extras);
  const sh = getOrMakeSheet_(ss, CONFIG.INV_SUMMARY_SHEET);
  const data = (rows||[]).map(o => {
    const fixedVals = fixedProps.map(p => o.raidKit && (o.raidKit[p] ?? '') || '');
    const baseVals = [o.character,o.file,o.logFile,o.created,o.modified].concat(fixedVals);
    const ex = o.kitExtras||{};
    const extraVals = extras.map(h => ex[h] ?? '');
    return baseVals.concat(extraVals);
  });
  upsertRowsByKey_(sh, header, 'Character', data);
}

function replaceInventorySummary_(ss, rows, meta){
  const fixedHeaders = (meta && meta.invFixedHeaders && meta.invFixedHeaders.length) ? meta.invFixedHeaders : [
    'Vial of Velium Vapors','Leatherfoot Raider Skullcap','Shiny Brass Idol','Ring of Shadows Count',
    'Reaper of the Dead','Pearl Count','Peridot Count','10 Dose Potion of Stinging Wort Count','Pegasus Feather Cloak',
    'MB Class Five','MB Class Four','MB Class Three','MB Class Two','MB Class One','Larrikan\'s Mask'
  ];
  const fixedProps = (meta && meta.invFixedProps && meta.invFixedProps.length) ? meta.invFixedProps : [
    'vialVeliumVapors','leatherfootSkullcap','shinyBrassIdol','ringOfShadowsCount',
    'reaperOfTheDead','pearlCount','peridotCount','tenDosePotionOfStingingWortCount','pegasusFeatherCloak',
    'mbClassFive','mbClassFour','mbClassThree','mbClassTwo','mbClassOne','larrikansMask'
  ];
  const base = ['Character','Inventory File','Source Log File','Created (UTC)','Modified (UTC)'].concat(fixedHeaders);
  const extrasSet = new Set();
  (rows||[]).forEach(o => { const ex = o.kitExtras||{}; Object.keys(ex).forEach(k => extrasSet.add(String(k))); });
  const extras = Array.from(extrasSet);
  const header = base.concat(extras);
  const sh = getOrMakeSheet_(ss, CONFIG.INV_SUMMARY_SHEET);
  const data = (rows||[]).map(o => {
    const fixedVals = fixedProps.map(p => o.raidKit && (o.raidKit[p] ?? '') || '');
    const baseVals = [o.character,o.file,o.logFile,o.created,o.modified].concat(fixedVals);
    const ex = o.kitExtras||{};
    const extraVals = extras.map(h => ex[h] ?? '');
    return baseVals.concat(extraVals);
  });
  writeAllRows_(sh, header, data);
}

function upsertInventoryDetails_(ss, rows){
  const header = ['Character','Inventory File','Created (UTC)','Modified (UTC)','Location','Name','ID','Count','Slots'];
  const sh = getOrMakeSheet_(ss, CONFIG.INV_ITEMS_SHEET);
  ensureHeader_(sh, header);
  const data = [];
  rows.forEach(o => {
    (o.items||[]).forEach(it => {
      data.push([o.character, o.file, o.created, o.modified, it.Location, it.Name, it.ID, it.Count, it.Slots]);
    });
  });
  if (data.length) sh.getRange(sh.getLastRow()+1,1,data.length,header.length).setValues(data);
}

function replaceInventoryDetails_(ss, rows){
  const header = ['Character','Inventory File','Created (UTC)','Modified (UTC)','Location','Name','ID','Count','Slots'];
  const sh = getOrMakeSheet_(ss, CONFIG.INV_ITEMS_SHEET);
  const data = [];
  (rows||[]).forEach(o => {
    (o.items||[]).forEach(it => {
      data.push([o.character, o.file, o.created, o.modified, it.Location, it.Name, it.ID, it.Count, it.Slots]);
    });
  });
  writeAllRows_(sh, header, data);
}

function replaceAll_(ss, body){
  const up = body.upserts || body || {};
  if (up.zones)    replaceZones_(ss, up.zones);
  // Factions JSON is ignored; use replaceFactionsCsv action instead
  if (up.inventory) replaceInventorySummary_(ss, up.inventory, body.meta || {});
  if (up.inventoryDetails) replaceInventoryDetails_(ss, up.inventoryDetails);
}

// Return unique character names currently present on any of the primary tabs.
function listCharacters_(ss){
  try{
    const tabs = [CONFIG.ZONES_SHEET, CONFIG.FACTION_SHEET, CONFIG.INV_SUMMARY_SHEET];
    const set = new Set();
    tabs.forEach(name => {
      const sh = ss.getSheetByName(name);
      if (!sh) return;
      const data = sh.getDataRange().getValues();
      if (!data || data.length < 2) return; // header + at least one row
      const header = data[0];
      const idx = header.indexOf('Character');
      if (idx < 0) return;
      for (let r=1; r<data.length; r++){
        const n = String(data[r][idx]||'').trim();
        if (n) set.add(n);
      }
    });
    return { ok:true, characters: Array.from(set).sort() };
  } catch(err){ return { ok:false, error: String(err && err.message || err) }; }
}

// Create a NEW sheet tab with a character's inventory (similar to screenshot)
function pushInventorySheet_(ss, body){
  const character = String(body.character||'').trim();
  const baseName = String(body.sheetName||'').trim() || ('Inventory - ' + character);
  const info = body.info || {};
  const items = body.items || [];
  if (!character) return { ok:false, error: 'Missing character' };

  // Unique sheet name
  let name = baseName, n=1;
  while (ss.getSheetByName(name)) { name = baseName + ' (' + (++n) + ')'; }
  const sh = ss.insertSheet(name);

  // Header rows (A1:D1, A2:D2)
  sh.getRange(1,1,1,4).setValues([['Inventory for','File','Created On','Modified On']]);
  sh.getRange(2,1,1,4).setValues([[character, info.file || '', info.created || '', info.modified || '']]);

  // Blank spacer row
  sh.getRange(3,1,1,1).setValue('');

  // Table header & data
  const header = ['Location','Name','ID','Count','Slots'];
  sh.getRange(5,1,1,header.length).setValues([header]);
  const data = items.map(it => [it.Location, it.Name, it.ID, it.Count, it.Slots]);
  if (data.length) sh.getRange(6,1,data.length,header.length).setValues(data);

  // Formatting
  sh.setFrozenRows(5);
  sh.autoResizeColumns(1, header.length);

  return { ok:true, sheet: name };
}

// Bulk JSON import for non-faction tabs. Each tab: { sheet(name), header:[], rows:[[]], mode:'replace'|'append' }
// CoV Faction sheet is intentionally skipped here to prevent JSON-based overwrites; use replaceFactionsCsv.
function jsonImport_(ss, body){
  const tabs = Array.isArray(body && body.tabs) ? body.tabs : [];
  let imported = 0;
  tabs.forEach(tab => {
    try{
      const name = String(tab.sheet || tab.name || '').trim();
      if (!name) return;
      if (name === CONFIG.FACTION_SHEET) return; // guard
      const header = Array.isArray(tab.header) ? tab.header : [];
      const rows = Array.isArray(tab.rows) ? tab.rows : [];
      const sh = getOrMakeSheet_(ss, name);
      const mode = String(tab.mode||'replace').toLowerCase();
      if (mode === 'append'){
        ensureHeader_(sh, header);
        if (rows.length) sh.getRange(sh.getLastRow()+1,1,rows.length,header.length).setValues(rows);
      } else {
        writeAllRows_(sh, header, rows);
      }
      imported++;
    } catch(err){}
  });
  return { imported };
}
`;
  document.getElementById('code').textContent = code;
  document.getElementById('copyAll').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(code);
      const el = document.getElementById('copyStatus');
      el.textContent = 'Copied to clipboard';
      setTimeout(() => el.textContent = '', 1500);
    } catch(e){
      const el = document.getElementById('copyStatus');
      el.textContent = 'Copy failed: ' + (e && e.message || e);
    }
  });
  </script>
</body>
</html>
